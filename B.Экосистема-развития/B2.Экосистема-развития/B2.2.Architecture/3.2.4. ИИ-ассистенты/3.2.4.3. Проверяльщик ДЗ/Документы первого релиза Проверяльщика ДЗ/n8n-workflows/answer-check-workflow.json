{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "check",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -384,
        0
      ],
      "id": "3e32920d-5774-4e07-a8ca-b260073252d0",
      "name": "Webhook",
      "webhookId": "b8f61c34-4c5e-45a4-a0b5-3c8d53c2a8a6"
    },
    {
      "parameters": {
        "jsCode": "const input = items[0]?.json ?? {};\nconst body = input.body ?? input;\n\nconst requiredBase = [\"answer_text\", \"question_text\", \"section_name\"];\nconst missingBase = requiredBase.filter((k) => !body?.[k]);\n\nconst hasGuide = !!body?.guide_slug;\nconst hasCourse = !!body?.course_name;\n\nconst missing = [\n  ...missingBase,\n  ...(!hasGuide && !hasCourse ? [\"course_name_or_guide_slug\"] : [])\n];\n\nconst courseToGuide = {\n  \"Системное саморазвитие\": \"systems-self-development\",\n  \"Systems Self Development\": \"systems-self-development\",\n  \"systems-self-development\": \"systems-self-development\"\n};\n\nconst request_id = `req_${Date.now()}_${Math.random().toString(16).slice(2)}`;\n\nif (missing.length) {\n  return [{\n    json: {\n      ok: false,\n      request_id,\n      status: 400,\n      body: {\n        ok: false,\n        request_id,\n        error: {\n          code: \"bad_request\",\n          message: `Missing required fields: ${missing.join(\", \")}`,\n          details: { missing }\n        }\n      }\n    }\n  }];\n}\n\nconst guide_slug = body.guide_slug || courseToGuide[body.course_name] || null;\nif (!guide_slug) {\n  return [{\n    json: {\n      ok: false,\n      request_id,\n      status: 400,\n      body: {\n        ok: false,\n        request_id,\n        error: {\n          code: \"bad_request\",\n          message: \"Unknown course_name (no mapping to guide_slug). Provide guide_slug or extend courseToGuide.\",\n          details: { course_name: body.course_name }\n        }\n      }\n    }\n  }];\n}\n\nconst chatInput = [\n  \"Тебе нужно проверить ответ стажера по нормативу из MCP.\",\n  \"\",\n  `course_name: ${body.course_name ?? \"\"}`,\n  `guide_slug: ${guide_slug}`,\n  `section_name: ${body.section_name}`,\n  \"\",\n  \"1) Вызови tool get_guide_sections(guide_slug).\",\n  \"2) Найди секцию по section_name (нормализуй: lower/trim, допускай близкое совпадение).\",\n  \"3) Вызови tool get_section_content(section_url) для выбранной секции и получи норматив.\",\n  \"4) Сравни answer_text с нормативом: полнота, корректность, терминология, структура.\",\n  \"\",\n  \"Верни ТОЛЬКО валидный JSON без markdown и без пояснений строго по схеме:\",\n  \"{\",\n  \"  \\\"verdict\\\": \\\"accepted\\\" | \\\"needs_revision\\\" | \\\"rejected\\\",\",\n  \"  \\\"score\\\": number (0..100),\",\n  \"  \\\"strengths\\\": string[],\",\n  \"  \\\"issues\\\": [{\\\"criterion\\\": string|null, \\\"issue\\\": string, \\\"suggestion\\\": string|null}],\",\n  \"  \\\"next_step\\\": string\",\n  \"}\",\n  \"\",\n  \"ДАНО:\",\n  \"## Вопрос\",\n  body.question_text,\n  \"\",\n  \"## Ответ стажера\",\n  body.answer_text\n].join(\"\\n\");\n\nreturn [{\n  json: {\n    ok: true,\n    request_id,\n    received_at: new Date().toISOString(),\n    debug: !!body.debug,\n\n    answer_text: body.answer_text,\n    question_text: body.question_text,\n    course_name: body.course_name ?? null,\n    section_name: body.section_name,\n    guide_slug,\n\n    chatInput\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -192,
        0
      ],
      "id": "519662c3-241a-43bb-aab4-984b7567d253",
      "name": "Validate + Map + Build chatInput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "a0c99f7d-7ed8-4ef7-bf55-7f4a57ce5c65",
              "leftValue": "={{$json.ok}}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -16,
        0
      ],
      "id": "838cd0f6-b07f-446a-a863-7ead44065d44",
      "name": "IF ok?"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{$json.chatInput}}",
        "options": {
          "systemMessage": "Ты — проверяющий ответ стажёра по нормативу из руководств (MCP).\n\nФОРМАТ ВЫХОДА:\nReturn a JSON object following the required schema; no extra text.\n\nВХОД (в тексте пользователя):\n- guide_slug\n- section_name\n- question_text\n- answer_text\n- (опционально) lang, по умолчанию \"ru\"\n\nАЛГОРИТМ (строго по порядку):\n\n1) Вызови tool get_guide_sections:\n   { \"guide_slug\": guide_slug, \"lang\": lang или \"ru\" }\n\n2) Найди секцию по section_name:\n   - Нормализуй section_name: trim + lower.\n   - Сопоставляй с section.title и section.slug (тоже lower/trim).\n   - Допускай fuzzy-совпадение.\n   - Если есть несколько близких и НЕТ уверенного выбора:\n     - НЕ вызывай get_section_content\n     - Верни verdict=\"needs_revision\", score=10 (округление ниже не применять)\n     - issues: один из \"section_ambiguous\" (и в suggestion перечисли до 5 кандидатов: title + slug)\n     - next_step: \"Уточните section_name (или укажите точный slug секции) и повторите проверку.\"\n   - Если не найдено ничего похожего:\n     - НЕ вызывай get_section_content\n     - Верни verdict=\"needs_revision\", score=0\n     - issues: \"section_not_found\"\n     - next_step: \"Проверьте section_name (или укажите slug) и повторите проверку.\"\n\n3) Если секция выбрана уверенно — вызови tool get_section_content:\n   { \"guide_slug\": guide_slug, \"section_slug\": выбранный section.slug, \"lang\": lang или \"ru\" }\n   ВАЖНО:\n   - НЕ используй section.url.\n   - section_slug бери ТОЛЬКО из slug результата get_guide_sections.\n\n4) Если get_section_content вернул \"Section not found\" или пустой/слишком короткий контент:\n   - Верни verdict=\"needs_revision\"\n   - score: 0..20 (обычно 0)\n   - issues обязательно включи: \"normative_missing\"\n   - next_step: \"Уточните section_name/guide_slug или проверьте наличие секции в MCP.\"\n\n5) Если норматив получен — оцени answer_text по нормативу:\n   - Полнота, корректность (противоречия), терминология, структура/логика, соответствие вопросу.\n   - Не цитируй большие фрагменты норматива; только кратко/перефраз.\n   - Выбор норматива (СТАБИЛЬНО): выдели РОВНО 2 смысловых блока из норматива:\n     (а) первый блок, где прямо определяют искомое понятие/явление из question_text,\n     (б) первый блок, где приводят причины/обоснование/следствия по теме вопроса.\n     Если (а) или (б) не нашлись — возьми ближайшие по смыслу, но всё равно ровно 2 блока.\n\nПРАВИЛА КОРРЕКТНОСТИ:\n- Правило доказуемости: помечай как accepted только если ключевые тезисы ответа подтверждаемы нормативом.\n- Правило противоречий: любое утверждение, противоречащее нормативу (например "за 2 дня", "диплом", "гарантии") => issue \"incorrect_claim\" и verdict не выше needs_revision (обычно rejected).\n- Если фрагмент является incorrect_claim — не ставь за него unsupported_claim (не дублируй).\n\nСТАБИЛЬНЫЙ ДЕТЕРМИНИРОВАННЫЙ СКОРИНГ (ОБЯЗАТЕЛЕН):\nA) Сформулируй РОВНО 5 ключевых тезисов по вопросу ТОЛЬКО из выбранных 2 блоков норматива.\n   - Если по нормативу тезисов меньше — всё равно дай 5, но допускай \"(не применимо)\" и НЕ штрафуй за него.\nB) Для каждого из 5 тезисов поставь метку: present / partial / absent.\nC) Посчитай:\n   - completeness = present*10 + partial*5 (0..50)\n   - correctness = 40\n       -20 за КАЖДЫЙ incorrect_claim\n       -10 за КАЖДЫЙ unsupported_claim\n     correctness не может быть ниже 0\n   - terminology = 0..5 (5 если терминология в целом совпадает; 0 если систематически не совпадает)\n   - structure = 0..5 (5 если логично/есть перечисления/прямой ответ; 0 если хаотично/мимо вопроса)\n   - score = completeness + correctness + terminology + structure\nD) Округляй score до ближайшего кратного 5.\nE) Вердикт строго по score:\n   - 90–100 accepted\n   - 60–89 needs_revision\n   - 0–59 rejected\nF) Если колеблешься между двумя оценками — выбирай более строгую (меньший score).\n\nISSUES (строго):\n- Максимум 4 пункта.\n- Без дублей по issue (уникализируй).\n- Если score снижается, в suggestion ЯВНО напиши почему и какой штраф применён (например: \"unsupported_claim: нет в нормативе, штраф -10\"; \"incorrect_claim: противоречит нормативу, штраф -20\"; \"absent тезис №3, влияет на completeness\").\n\nСХЕМА ВЫХОДА (ТОЛЬКО JSON):\n{\n  \"verdict\": \"accepted\" | \"needs_revision\" | \"rejected\",\n  \"score\": number,\n  \"strengths\": string[],\n  \"issues\": [\n    { \"criterion\": string|null, \"issue\": string, \"suggestion\": string|null }\n  ],\n  \"next_step\": string\n}\n\nОграничения:\n- strengths: 0..6 коротких пунктов.\n- issues: 0..4 пункта, без повторов.\n- next_step: одно конкретное действие (что исправить/что сделать дальше).\n\n",
          "returnIntermediateSteps": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        208,
        -176
      ],
      "id": "3d33caa2-3f21-4248-bae8-1cb5ec1f5a15",
      "name": "Tools AI Agent (LLM calls MCP)",
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "claude-3-5-haiku-20241022",
          "mode": "list",
          "cachedResultName": "Claude Haiku 3.5"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        112,
        112
      ],
      "id": "4f6f6b65-d137-4ba9-95b5-dbbee1b193d5",
      "name": "Anthropic Chat Model",
      "credentials": {
        "anthropicApi": {
          "id": "HaAsfAfQlU8aeORX",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const ctx = items?.[0]?.json ?? {};\n\n// =========================\n// 0) Pass-through error branch (если вдруг сюда попала ошибка из Validate)\n// =========================\nif (ctx?.ok === false && ctx?.status && ctx?.body) {\n  const st = Number(String(ctx.status).trim());\n  return [{ json: { status: Number.isFinite(st) ? st : 400, needs_repair: false, body: ctx.body } }];\n}\n\n// =========================\n// 1) Minimal "do we have ANY model output?" guard\n//    Важно: НЕ требуем ctx.output быть object — допускаем строку.\n// =========================\nconst pickFirstNonNull = (...vals) => {\n  for (const v of vals) if (v !== undefined && v !== null) return v;\n  return null;\n};\n\nconst outputRaw = pickFirstNonNull(\n  ctx.output,\n  ctx.text,\n  ctx.response,\n  ctx.result,\n  ctx.data,\n  ctx.completion\n);\n\nconst hasAnyLLMOutput =\n  outputRaw !== null &&\n  (typeof outputRaw === \"object\" ||\n    typeof outputRaw === \"number\" ||\n    typeof outputRaw === \"boolean\" ||\n    (typeof outputRaw === \"string\" && outputRaw.trim().length > 0));\n\nif (!hasAnyLLMOutput) {\n  const errText = ctx.error?.message || ctx.error?.description || ctx.error || null;\n\n  return [{\n    json: {\n      status: 200,\n      needs_repair: true,\n      body: {\n        ok: true,\n        request_id: ctx.request_id,\n        received_at: ctx.received_at,\n        checked_at: new Date().toISOString(),\n        guide_slug: ctx.guide_slug,\n        course_name: ctx.course_name ?? null,\n        section_name: ctx.section_name,\n\n        verdict: \"needs_revision\",\n        score: 0,\n        strengths: [],\n        issues: [{\n          criterion: null,\n          issue: \"model_output_missing\",\n          suggestion: errText ? String(errText).slice(0, 800) : \"No model output fields found (output/text/response/result).\"\n        }],\n        next_step: \"Повторите запрос; проверьте выполнение агента, модель и доступность MCP.\",\n        comment: \"**На доработку** (0/100)\\n\\n**Сильные стороны:**\\n—\\n\\n**Замечания:**\\n- критерий: model_output_missing\\n\\n**Следующий шаг:**\\nПовторите запрос.\"\n      }\n    }\n  }];\n}\n\n// =========================\n// Helpers\n// =========================\nconst safeString = (v) => (v == null ? \"\" : typeof v === \"string\" ? v : (() => {\n  try { return JSON.stringify(v); } catch { return String(v); }\n})());\n\nconst norm = (s) => safeString(s).trim().toLowerCase();\nconst clampInt = (n, lo, hi) => Math.max(lo, Math.min(hi, n));\n\nconst stripWrappers = (s) => {\n  let x = safeString(s);\n\n  // remove BOM + trim\n  x = x.replace(/^\\uFEFF/, \"\").trim();\n\n  // remove <result> wrappers\n  x = x.replace(/<result>\\s*/gi, \"\").replace(/\\s*<\\/result>/gi, \"\");\n\n  // remove fenced code blocks markers (keep inside)\n  x = x.replace(/```json\\s*/gi, \"\").replace(/```\\s*/g, \"\");\n\n  // replace smart quotes to normal quotes\n  x = x.replace(/[""]/g, '\"').replace(/['']/g, \"'\");\n\n  return x.trim();\n};\n\n// Extract first valid JSON object using brace scan with string-awareness\nconst extractFirstJSONObject = (s) => {\n  const str = stripWrappers(s);\n  const start = str.indexOf(\"{\");\n  if (start === -1) return null;\n\n  let inString = false;\n  let escaped = false;\n  let depth = 0;\n  let end = -1;\n\n  for (let i = start; i < str.length; i++) {\n    const ch = str[i];\n\n    if (inString) {\n      if (escaped) escaped = false;\n      else if (ch === \"\\\\\") escaped = true;\n      else if (ch === '\"') inString = false;\n      continue;\n    }\n\n    if (ch === '\"') { inString = true; continue; }\n\n    if (ch === \"{\") depth++;\n    if (ch === \"}\") depth--;\n\n    if (depth === 0) { end = i; break; }\n  }\n\n  if (end === -1) return null;\n\n  let candidate = str.slice(start, end + 1).trim();\n  candidate = candidate.replace(/,\\s*}/g, \"}\").replace(/,\\s*]/g, \"]\");\n  return candidate;\n};\n\nconst tryParseJSON = (rawText) => {\n  const cleaned = stripWrappers(rawText);\n  const candidate = extractFirstJSONObject(cleaned);\n  if (!candidate) return { parsed: null, raw: cleaned, cleanedCandidate: null, error: \"no_json_object_found\" };\n\n  try {\n    return { parsed: JSON.parse(candidate), raw: cleaned, cleanedCandidate: candidate, error: null };\n  } catch {\n    const fbStart = cleaned.indexOf(\"{\");\n    const fbEnd = cleaned.lastIndexOf(\"}\");\n    if (fbStart !== -1 && fbEnd > fbStart) {\n      const wide = cleaned.slice(fbStart, fbEnd + 1)\n        .replace(/,\\s*}/g, \"}\")\n        .replace(/,\\s*]/g, \"]\");\n      try {\n        return { parsed: JSON.parse(wide), raw: cleaned, cleanedCandidate: wide, error: null };\n      } catch {\n        return { parsed: null, raw: cleaned, cleanedCandidate: candidate, error: \"json_parse_failed\" };\n      }\n    }\n    return { parsed: null, raw: cleaned, cleanedCandidate: candidate, error: \"json_parse_failed\" };\n  }\n};\n\n// Levenshtein similarity\nconst levenshtein = (a, b) => {\n  a = safeString(a); b = safeString(b);\n  const n = a.length, m = b.length;\n  if (!n) return m;\n  if (!m) return n;\n\n  const dp = Array.from({ length: n + 1 }, () => new Array(m + 1).fill(0));\n  for (let i = 0; i <= n; i++) dp[i][0] = i;\n  for (let j = 0; j <= m; j++) dp[0][j] = j;\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= m; j++) {\n      const cost = a[i - 1] === b[j - 1] ? 0 : 1;\n      dp[i][j] = Math.min(\n        dp[i - 1][j] + 1,\n        dp[i][j - 1] + 1,\n        dp[i - 1][j - 1] + cost\n      );\n    }\n  }\n  return dp[n][m];\n};\n\nconst similarity = (a, b) => {\n  a = norm(a); b = norm(b);\n  if (!a || !b) return 0;\n  if (a === b) return 1;\n  if (a.includes(b) || b.includes(a)) return 0.86;\n\n  const dist = levenshtein(a, b);\n  const maxLen = Math.max(a.length, b.length) || 1;\n  return 1 - dist / maxLen;\n};\n\n// =========================\n// 2) Get model output (object or string)\n// =========================\nlet parsed = null;\nlet rawLLM = null;\nlet cleanedCandidate = null;\nlet parseError = null;\nlet parseFailed = false;\n\n// Prefer structured output (если outputParser был включён и дал объект)\nif (ctx.output && typeof ctx.output === \"object\" && ctx.output.verdict) {\n  parsed = ctx.output;\n  rawLLM = safeString(ctx.output);\n} else {\n  const raw = safeString(outputRaw);\n  const r = tryParseJSON(raw);\n  parsed = r.parsed;\n  rawLLM = r.raw;\n  cleanedCandidate = r.cleanedCandidate;\n  parseError = r.error;\n}\n\nif (!parsed || typeof parsed !== \"object\") {\n  parseFailed = true;\n  parsed = {\n    verdict: \"needs_revision\",\n    score: 0,\n    strengths: [],\n    issues: [{\n      criterion: null,\n      issue: \"LLM_output_not_parseable\",\n      suggestion: (cleanedCandidate || rawLLM || \"(empty)\").slice(0, 800)\n    }],\n    next_step: \"Return strict JSON per schema\"\n  };\n}\n\n// =========================\n// 3) Evidence check via intermediateSteps\n// =========================\nconst steps = Array.isArray(ctx.intermediateSteps)\n  ? ctx.intermediateSteps\n  : Array.isArray(ctx.returnIntermediateSteps)\n    ? ctx.returnIntermediateSteps\n    : [];\n\nconst normalizeObsToArray = (obs) => {\n  if (obs == null) return [];\n  if (Array.isArray(obs)) return obs;\n  if (typeof obs === \"string\") {\n    try {\n      const obj = JSON.parse(obs);\n      return Array.isArray(obj) ? obj : [obj];\n    } catch {\n      return [];\n    }\n  }\n  if (typeof obs === \"object\") return [obs];\n  return [];\n};\n\nconst getRpcTextById = (rpcId) => {\n  for (const s of steps) {\n    const arr = normalizeObsToArray(s?.observation);\n    for (const entry of arr) {\n      if (entry?.id === rpcId) {\n        const t = entry?.result?.content?.[0]?.text;\n        return typeof t === \"string\" ? t : \"\";\n      }\n    }\n  }\n  return \"\";\n};\n\nconst sectionsText = getRpcTextById(\"sections-1\");\nconst normativeText = getRpcTextById(\"section-1\");\n\nlet sections = null;\ntry {\n  const st = (sectionsText || \"\").trim();\n  sections = st.startsWith(\"[\") ? JSON.parse(st) : null;\n} catch {\n  sections = null;\n}\n\nconst toolsSectionsCalled = !!sectionsText;\nconst toolsSectionCalled = !!normativeText;\n\nconst normativeMissing =\n  !normativeText ||\n  /^\\s*Section not found\\s*$/i.test(normativeText) ||\n  normativeText.trim().length < 50;\n\n// =========================\n// 4) Section resolution checks (not found / ambiguous)\n// =========================\nconst sectionNameIn = safeString(ctx.section_name);\nconst sectionNeedle = norm(sectionNameIn);\n\nlet sectionNotFound = false;\nlet sectionAmbiguous = false;\nlet bestMatch = null;\n\nif (Array.isArray(sections) && sectionNeedle) {\n  const scored = sections.map((sec) => {\n    const title = sec?.title ?? \"\";\n    const slug = sec?.slug ?? \"\";\n    const score = Math.max(similarity(sectionNeedle, title), similarity(sectionNeedle, slug));\n    return { sec, score, title, slug };\n  }).sort((a, b) => b.score - a.score);\n\n  const top1 = scored[0];\n  const top2 = scored[1];\n\n  bestMatch = top1?.sec ?? null;\n\n  if (!top1 || top1.score < 0.55) {\n    sectionNotFound = true;\n  } else if (top2 && top1.score >= 0.70 && top2.score >= 0.70 && (top1.score - top2.score) < 0.08) {\n    sectionAmbiguous = true;\n  }\n}\n\n// =========================\n// 5) Deterministic fail overrides (защита от \"accepted из воздуха\")\n// =========================\nif (!toolsSectionsCalled || !toolsSectionCalled) {\n  parsed = {\n    verdict: \"needs_revision\",\n    score: 0,\n    strengths: [],\n    issues: [{\n      criterion: null,\n      issue: \"tools_not_called\",\n      suggestion: \"Проверьте, что agent реально вызывает get_guide_sections и get_section_content, и что returnIntermediateSteps включён.\"\n    }],\n    next_step: \"Исправьте вызовы инструментов/настройки агента и повторите проверку.\"\n  };\n}\n\nif (sectionNotFound) {\n  parsed = {\n    verdict: \"needs_revision\",\n    score: 0,\n    strengths: [],\n    issues: [{\n      criterion: null,\n      issue: \"section_not_found\",\n      suggestion: \"Уточните section_name (точный title или slug из списка секций) и повторите проверку.\"\n    }],\n    next_step: \"Уточните section_name и повторите проверку.\"\n  };\n} else if (sectionAmbiguous) {\n  const candidates = Array.isArray(sections)\n    ? sections\n      .map((sec) => {\n        const score = Math.max(similarity(sectionNeedle, sec?.title ?? \"\"), similarity(sectionNeedle, sec?.slug ?? \"\"));\n        return { title: sec?.title ?? \"\", slug: sec?.slug ?? \"\", score };\n      })\n      .sort((a, b) => b.score - a.score)\n      .slice(0, 5)\n      .map((c) => `${c.title} (${c.slug})`)\n    : [];\n\n  parsed = {\n    verdict: \"needs_revision\",\n    score: 10,\n    strengths: [],\n    issues: [{\n      criterion: null,\n      issue: \"section_ambiguous\",\n      suggestion: candidates.length\n        ? `Уточните section_name. Ближайшие кандидаты: ${candidates.join(\"; \")}`\n        : \"Уточните section_name (слишком неоднозначно).\"\n    }],\n    next_step: \"Уточните section_name (точный title или slug) и повторите проверку.\"\n  };\n}\n\nif (normativeMissing) {\n  parsed = {\n    verdict: \"needs_revision\",\n    score: 0,\n    strengths: [],\n    issues: [\n      ...(sectionNotFound ? [{\n        criterion: null,\n        issue: \"section_not_found\",\n        suggestion: \"Уточните section_name или проверьте, что секция существует.\"\n      }] : []),\n      {\n        criterion: null,\n        issue: \"normative_missing\",\n        suggestion: \"Проверьте guide_slug/section_name и доступность MCP; норматив должен возвращаться из get_section_content.\"\n      }\n    ],\n    next_step: \"Уточните section_name/guide_slug и повторите проверку (норматив должен быть получен из MCP).\"\n  };\n}\n\n// =========================\n// 6) Lightweight "sanity guard" against obvious hallucinations\n// =========================\nconst answerText = safeString(ctx.answer_text);\nif (normativeText && !normativeMissing) {\n  const redFlags = [\n    { re: /\\bза\\s*2\\s*дн(я|ей)\\b/i, code: \"unrealistic_timeframe\" },\n    { re: /\\bза\\s*вечер\\b/i, code: \"unrealistic_timeframe\" },\n    { re: /\\bдиплом\\b/i, code: \"unsupported_outcome\" },\n    { re: /\\bсертификат\\b/i, code: \"unsupported_outcome\" },\n    { re: /\\bгарантированн(ое|ый|ая)\\b/i, code: \"unsupported_outcome\" },\n    { re: /\\bгарантия\\b/i, code: \"unsupported_outcome\" },\n    { re: /\\bповышени(е|я)\\b/i, code: \"unsupported_outcome\" },\n    { re: /\\bбез\\s+практик(и|)\\b/i, code: \"contradicts_practice_requirement\" }\n  ];\n\n  const normativeLower = norm(normativeText);\n  const hits = redFlags\n    .filter(({ re }) => re.test(answerText))\n    .filter(({ re }) => !re.test(normativeLower));\n\n  if (hits.length && (parsed.verdict === \"accepted\" || (typeof parsed.score === \"number\" && parsed.score >= 60))) {\n    parsed = {\n      verdict: \"rejected\",\n      score: 10,\n      strengths: [],\n      issues: [{\n        criterion: \"Полнота и корректность ответа\",\n        issue: \"incorrect_claims\",\n        suggestion: `В ответе есть утверждения, не поддержанные нормативом: ${hits.map(h => h.code).join(\", \")}. Уберите обещания/гарантии и опишите результаты и режим из текста раздела.`\n      }],\n      next_step: \"Перепишите ответ строго по нормативу (цель, результаты, режим прохождения) без гарантий и фантазийных обещаний.\"\n    };\n  }\n}\n\n// =========================\n// 7) Normalize output fields\n// =========================\nconst verdictAllowed = new Set([\"accepted\", \"needs_revision\", \"rejected\"]);\nif (!verdictAllowed.has(parsed.verdict)) parsed.verdict = \"needs_revision\";\n\nconst score =\n  (typeof parsed.score === \"number\" && isFinite(parsed.score))\n    ? clampInt(Math.round(parsed.score), 0, 100)\n    : 0;\n\nconst strengths = Array.isArray(parsed.strengths)\n  ? parsed.strengths.map((x) => safeString(x)).filter(Boolean).slice(0, 6)\n  : [];\n\nconst issues = Array.isArray(parsed.issues)\n  ? parsed.issues\n    .map((i) => ({\n      criterion: (i?.criterion === null || typeof i?.criterion === \"string\") ? i.criterion : null,\n      issue: safeString(i?.issue),\n      suggestion: (i?.suggestion === null || typeof i?.suggestion === \"string\") ? i.suggestion : null\n    }))\n    .filter((i) => i.issue)\n    .slice(0, 8)\n  : [];\n\nconst next_step = safeString(parsed.next_step) || \"—\";\n\n// =========================\n// 8) Comment (markdown для UI)\n// =========================\nconst verdictMap = { accepted: \"✓ Принято\", needs_revision: \"На доработку\", rejected: \"Не принято\" };\nconst strengthsMd = strengths.length ? strengths.map((s) => `- ${s}`).join(\"\\n\") : \"—\";\nconst issuesMd = issues.length\n  ? issues.map((i) =>\n    `- ${i.criterion || \"критерий\"}: ${i.issue}` + (i.suggestion ? `\\n  _Рекомендация: ${i.suggestion}_` : \"\")\n  ).join(\"\\n\")\n  : \"—\";\n\nconst comment = [\n  `**${verdictMap[parsed.verdict] || parsed.verdict}** (${score}/100)`,\n  \"\",\n  \"**Сильные стороны:**\",\n  strengthsMd,\n  \"\",\n  \"**Замечания:**\",\n  issuesMd,\n  \"\",\n  \"**Следующий шаг:**\",\n  next_step\n].join(\"\\n\");\n\n// =========================\n// 9) Envelope (+ debug)\n// =========================\nconst body = {\n  ok: true,\n  request_id: ctx.request_id,\n  received_at: ctx.received_at,\n  checked_at: new Date().toISOString(),\n\n  guide_slug: ctx.guide_slug,\n  course_name: ctx.course_name,\n  section_name: ctx.section_name,\n\n  verdict: parsed.verdict,\n  score,\n  strengths,\n  issues,\n  next_step,\n  comment,\n\n  ...(ctx.debug ? {\n    raw_llm: rawLLM,\n    cleaned_candidate: cleanedCandidate,\n    parse_failed: !!parseFailed,\n    parse_error: parseError,\n    evidence: {\n      toolsSectionsCalled,\n      toolsSectionCalled,\n      normativeMissing,\n      sectionNotFound,\n      sectionAmbiguous,\n      bestMatch: bestMatch ? { title: bestMatch.title, slug: bestMatch.slug } : null\n    },\n    intermediateSteps: ctx.intermediateSteps ?? ctx.returnIntermediateSteps ?? null\n  } : {})\n};\n\n// needs_repair: только когда реально не смогли распарсить JSON\nconst needs_repair = !!parseFailed;\n\nreturn [{ json: { status: 200, needs_repair, body } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        496,
        -176
      ],
      "id": "29707a8b-464c-4587-b660-da808e632db7",
      "name": "Parse + Format + Envelope"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{$json.body ?? $json}}",
        "options": {
          "responseCode": "={{ Number($json.status ?? 200) }}"
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        688,
        16
      ],
      "id": "cc4b49e3-8337-44b0-a575-09eadf910519",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "toolDescription": "Returns sections: {slug,title,url,order}",
        "method": "POST",
        "url": "https://guides-mcp.aisystant.workers.dev/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ ({\n  jsonrpc: \"2.0\",\n  id: \"sections-1\",\n  method: \"tools/call\",\n  params: {\n    name: \"get_guide_sections\",\n    arguments: {\n      guide_slug: $fromAI(\"guide_slug\"),\n      lang: \"ru\"\n    }\n  }\n}) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.3,
      "position": [
        256,
        112
      ],
      "id": "1e975115-d2b8-4ef0-9111-8d409633e146",
      "name": "get_guide_sections"
    },
    {
      "parameters": {
        "toolDescription": "Call with {guide_slug, section_slug, lang}. Returns markdown.",
        "method": "POST",
        "url": "https://guides-mcp.aisystant.workers.dev/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ ({\n  jsonrpc: \"2.0\",\n  id: \"section-1\",\n  method: \"tools/call\",\n  params: {\n    name: \"get_section_content\",\n    arguments: {\n      guide_slug: $fromAI(\"guide_slug\"),\n      section_slug: $fromAI(\"section_slug\"),\n      lang: \"ru\"\n    }\n  }\n}) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequestTool",
      "typeVersion": 4.3,
      "position": [
        432,
        112
      ],
      "id": "67caa48f-fc5b-4c60-ac03-be87f1f1192d",
      "name": "get_section_content"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate + Map + Build chatInput",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate + Map + Build chatInput": {
      "main": [
        [
          {
            "node": "IF ok?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF ok?": {
      "main": [
        [
          {
            "node": "Tools AI Agent (LLM calls MCP)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tools AI Agent (LLM calls MCP)": {
      "main": [
        [
          {
            "node": "Parse + Format + Envelope",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anthropic Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Tools AI Agent (LLM calls MCP)",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Parse + Format + Envelope": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get_guide_sections": {
      "ai_tool": [
        [
          {
            "node": "Tools AI Agent (LLM calls MCP)",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_section_content": {
      "ai_tool": [
        [
          {
            "node": "Tools AI Agent (LLM calls MCP)",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "dc4dc209c8be8aaf73edd2ae3910dee970fc11e13c686e407a12a7a4d2098e85"
  }
}
