---
type: adr
status: accepted
version: 1.0
created: 2025-12-24
layer: architecture
scope: ecosystem
security: internal
related:
  - "Общая архитектура ИТ-платформы 3.2"
  - "Карта ИТ-систем 3.2"
description: "ADR: архитектура ИИ-ассистентов на основе конечного автомата (FSM) с MCP-сервером"
---

# FSM-архитектура ИИ-ассистентов

> **ADR (Architecture Decision Record):** Архитектурное решение для организации логики ИИ-ассистентов на основе конечного автомата (FSM) с MCP-сервером.

---

## 0. Резюме решения

**Проблема:** Как организовать сложную логику ИИ-ассистентов так, чтобы:
- Диалог был предсказуемым и структурированным
- Разработчики и методологи могли создавать сценарии без программирования
- Система корректно работала при отсутствии данных

**Решение:** Использовать паттерн **Finite State Machine (FSM)** — каждое состояние описано в markdown-файле с инструкциями, а MCP-сервер выдаёт эти инструкции по запросу LLM.

**Референсная реализация:** [github.com/aisystant/fsm-mcp](https://github.com/aisystant/fsm-mcp) — Ассистент Ученика на Cloudflare Workers.

---

## 1. Контекст и проблема

### 1.1 Что такое ИИ-ассистент в экосистеме

**Ассистент** — это не отдельная программа, а комбинация:

```
Ассистент = LLM + Системный промпт + MCP-сервер
```

| Компонент | Роль |
|-----------|------|
| **LLM** (Claude, GPT) | «Мозг» — понимает речь, генерирует ответы |
| **Системный промпт** | «Конституция» — роль, принципы, ограничения |
| **MCP-сервер** | «Навигатор» — выдаёт инструкции для текущего сценария |

LLM сам по себе не знает про ступени ученика или помидорки. Всё это знание приходит из инструкций.

### 1.2 Проблемы без FSM

| Проблема | Последствие |
|----------|-------------|
| Логика «зашита» в промпт | Сложно поддерживать, промпт разрастается |
| Нет явной структуры диалога | Ассистент «теряется» в длинных разговорах |
| Непредсказуемые переходы | LLM импровизирует, нарушая сценарий |
| Нет деградации | Отсутствие данных ломает диалог |

### 1.3 Что даёт FSM

- **Предсказуемость** — ассистент всегда знает, где находится и куда может перейти
- **Структурированность** — каждое состояние решает одну задачу
- **Устойчивость** — отсутствие данных не ломает сценарий, а переводит в режим деградации
- **Прозрачность** — автомат служит документацией для всех сценариев

---

## 2. Архитектурное решение

### 2.1 Сущности системы

| Сущность | Что это | Роль |
|----------|---------|------|
| **Пользователь** | Человек | Общается с ассистентом |
| **LLM** | Claude, GPT и др. | Исполнитель инструкций, ведёт диалог |
| **MCP-сервер** | fsm-mcp на Workers | Выдаёт инструкции состояний по запросу LLM |
| **Цифровой двойник** | Внешний сервис | Хранит данные пользователя |

### 2.2 Как работает один «шаг»

```
LLM вызывает get_instruction() → получает инструкции состояния →
→ следует им → по ответу пользователя вызывает get_instruction(state) →
→ получает новые инструкции → продолжает диалог
```

На каждом сообщении пользователя LLM выполняет цикл:

1. **Определить текущее состояние** (держит в контексте диалога)
2. **Прочитать инструкции состояния** + базовые правила
3. **Решить, нужны ли данные из ЦД:**
   - если нужны и нет согласия → `dt_consent`
   - если согласие есть → загрузить данные
   - если данных нет → `no_dt_mode` (заменить на вопросы)
4. **Сформировать ответ** по инструкциям
5. **Если нужно сменить сценарий** → вызвать `get_instruction(state: "...")`

### 2.3 Структура FSM-репозитория

```
fsm-mcp/
├── src/                  # Исходный код MCP-сервера
│   ├── index.ts          # Точка входа
│   └── states.ts         # Реестр состояний
│
├── states/               # Состояния FSM (читает LLM)
│   ├── init.md           # Начальное состояние
│   ├── route_intent.md   # Маршрутизация намерений
│   ├── test_start.md     # Тест ступени
│   ├── plan_entry.md     # Планирование
│   ├── weekly_reflection.md
│   └── ...
│
├── instructions/         # Базовые правила (системный промпт)
│   ├── system.md         # Роль, принципы, ограничения
│   └── consent.md        # Правила согласия
│
├── knowledge/            # Справочники для людей
│   ├── how-it-works.md   # Архитектура
│   ├── levels_table.md   # Критерии ступеней
│   ├── memes.md          # Типовые мемы
│   └── test-scenarios/   # Тестовые сценарии
│
└── schemas/              # JSON-схемы для ЦД
    ├── assessment.json
    ├── weekly_plan.json
    └── weekly_reflection.json
```

### 2.4 Кто что читает

| Папка | Кто читает | Когда |
|-------|-----------|-------|
| `src/` | Разработчик | При доработке сервера |
| `states/` | LLM | В рантайме через `get_instruction()` |
| `instructions/` | LLM | Всегда (системный промпт) |
| `knowledge/` | Разработчик, тестировщик | При разработке |
| `schemas/` | ЦД | При сохранении данных |

---

## 3. Двухслойная система инструкций

### Слой 1: База (instructions/)

«Конституция» — действует во всех состояниях:

- **Роль:** развивать практики Ученика, не оценивать личность
- **Единица работы:** помидорка (25–45 минут фокусной работы)
- **Принципы:** систематичность важнее идеальности
- **Формат:** 2–3 шага на неделю + 1 микрошаг на сегодня
- **Ограничения:** максимум 3 уточняющих вопроса

### Слой 2: Сценарии (states/)

Каждое состояние решает **одну задачу** и содержит:

- Цель состояния
- Шаги диалога
- Переходы (условие → следующее состояние)
- Деградацию (что делать без данных)

---

## 4. Формат файла состояния

Пример `states/weekly_reflection.md`:

```markdown
# Состояние: weekly_reflection

## Цель
Провести рефлексию за неделю, зафиксировать достижения и точки роста.

## Триггеры входа
- Пользователь просит "подвести итоги недели"
- Переход из `init` при соответствующем намерении

## Шаги

### 1. Получение данных
Если есть согласие — загрузить через `dt_load_week`.
Если нет — задать 2-3 вопроса:
- Сколько помидорок удалось сделать?
- Что получилось особенно хорошо?

### 2. Формирование итога
Структурировать: достижения, сложности, инсайты.

### 3. Предложение сохранить
Если согласие на запись — перейти в `weekly_reflection_save`.

## Переходы

| Условие | Следующее состояние |
|---------|---------------------|
| Сохранить | `weekly_reflection_save` |
| Планировать дальше | `next_week_planning` |
| Разобрать затык | `blocker_debug` |
| Завершить | `init` |

## Деградация
Если данных нет — заменить запросы на 1–3 вопроса пользователю.
```

---

## 5. Слой согласия

Согласие вынесено в отдельные состояния:

| Состояние | Назначение |
|-----------|------------|
| `dt_consent` | Спрашивает разрешение на чтение/запись |
| `dt_load_profile` | Загружает контекст (цели, ступень) |
| `dt_load_week` | Загружает недельную сводку |
| `no_dt_mode` | Режим без данных — вопросы вместо запросов |

**Принципы:**
- Приватность по умолчанию
- Минимизация запрашиваемых данных
- Одинаковое поведение во всех ветках

---

## 6. Граф переходов (упрощённый)

```
┌─────────────────────────────────────────────────────────────────┐
│                           init                                   │
│  (встреча, показ меню, грубое распознавание)                     │
└─────────────────────────────────────────────────────────────────┘
         │              │              │              │
         ▼              ▼              ▼              ▼
   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
   │test_start│  │plan_entry│  │ weekly_  │  │ blocker_ │
   │          │  │          │  │reflection│  │  debug   │
   └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘
        │             │             │             │
        ▼             ▼             ▼             ▼
   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
   │  test_   │  │ plan_by_ │  │reflection│  │  meme_   │
   │questions │  │  days    │  │  _save   │  │experiment│
   └────┬─────┘  └────┬─────┘  └────┬─────┘  └────┬─────┘
        │             │             │             │
        ▼             ▼             ▼             │
   ┌──────────┐  ┌──────────┐  ┌──────────┐       │
   │ assess_  │  │  plan_   │  │next_week_│       │
   │  stage   │  │invariants│  │ planning │       │
   └────┬─────┘  └────┬─────┘  └──────────┘       │
        │             │                           │
        └─────────────┴───────────────────────────┘
                            │
                            ▼
                         init
```

**Основные ветки:**

| Сценарий | Состояния |
|----------|-----------|
| Тест ступени | `init` → `test_start` → `test_questions` → `assess_stage` → `assessment_result` → `init` |
| План недели | `init` → `plan_entry` → `plan_by_days` → `plan_invariants` → `plan_save` → `init` |
| Итоги недели | `init` → `weekly_reflection` → `weekly_reflection_save` → `next_week_planning` → `init` |
| Работа с затыком | `init` → `blocker_debug` → `meme_experiment` → `init` |

---

## 7. MCP-интерфейс

### 7.1 Единственный инструмент

```typescript
get_instruction(state?: string): InstructionResponse
```

- Без параметра — возвращает инструкции текущего/начального состояния
- С параметром `state` — переход в указанное состояние

### 7.2 Подключение к LLM

MCP-эндпоинт: `POST /mcp`

```json
{
  "mcpServers": {
    "student-assistant": {
      "url": "https://fsm-mcp.aisystant.workers.dev/mcp"
    }
  }
}
```

---

## 8. Принципы проектирования

### 8.1 Для состояний

1. **Одно состояние — одна цель**
2. **Явные переходы** — нет «магических» переходов по умолчанию
3. **Деградация** — если данных нет, заменить на 1–3 вопроса
4. **Минимизация** — запрашивать только нужное

### 8.2 Для системы

1. **Один инструмент** — `get_instruction()` как единственная точка перехода
2. **Согласие отдельным слоем** — повторяется в разных сценариях
3. **Knowledge отделён от states** — справочники для людей, не для LLM
4. **Схемы как контракт** — данные в ЦД валидируются по JSON Schema

---

## 9. Пример диалога

```
Пользователь: Привет

LLM: [вызывает get_instruction()]
LLM: Привет! Я — Ассистент Ученика. Чем могу помочь?
     • Подвести итоги недели
     • Спланировать обучение
     • Определить ступень

Пользователь: Протестируй меня

LLM: [вызывает get_instruction(state: "test_start")]
LLM: Давайте определим вашу ступень. Есть ли у вас
     ежедневный слот для изучения материалов?

Пользователь: Стараюсь каждый день, но часто сбиваюсь

LLM: [вызывает get_instruction(state: "assess_stage")]
LLM: **Ваша ступень: Практикующий**

     Признаки: есть намерение, ритм около недели, потом сбой.

     Для перехода к Систематическому:
     • Удерживать практику 2+ недели подряд
     • Создавать рабочие продукты
```

---

## 10. Роли разработчиков

| Роль | Зона ответственности | Навыки |
|------|----------------------|--------|
| **Методолог** | Состояния, сценарии, вопросы | Markdown, UX диалогов |
| **Архитектор** | Структура FSM, переходы | Системное мышление |
| **Разработчик** | MCP-сервер, интеграция с ЦД | TypeScript, Cloudflare Workers |
| **Тестировщик** | Тестовые сценарии | Прогон диалогов |

---

## 11. Связанные документы

- [[Общая архитектура ИТ-платформы 3.2]] — место FSM в слоистой архитектуре
- [[Карта ИТ-систем 3.2]] — полный реестр компонентов
- [github.com/aisystant/fsm-mcp](https://github.com/aisystant/fsm-mcp) — референсная реализация

---

## Changelog

| Дата | Версия | Изменения |
|------|--------|-----------|
| 2025-12-24 | v1.0 | Документ создан на основе реализации fsm-mcp. Статус: accepted |
