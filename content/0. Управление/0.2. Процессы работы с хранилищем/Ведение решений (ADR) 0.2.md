---
type: doc
audience: mixed
edit_mode: mixed
layer: methodology
scope: local-edge
security: internal
status: in_progress
version: 0.1
created: 2025-11-13
---

# 0.3. Решения

Этот документ — реестр ключевых решений (ADR): краткие контекст-решение-последствия с ссылками на идеи, системы и дорожную карту; нужен для памяти проекта и аудита логики развития.

---

## Вопросы для обсуждения

### 1. Организация хранения информации проекта

**Контекст**
В проекте присутствует множество различных типов информации, которые требуют разных подходов к хранению, версионированию и доступу. Необходимо определить единую стратегию размещения и управления всеми артефактами экосистемы.

**Типы информации:**
- **Высокоуровневая информация** — видение, миссия, стратегия, концепция функционирования экосистемы, принципы развития
- **Методология и знания** — руководства, программы обучения, понятийный аппарат, картотека, онтология, в том числе чанки, понятия и данные из клуба, телеграм-чатов и т.п. (может последнее выделить отдельно?). 
- **Архитектурная документация** — описания подсистем, схемы интеграций, ADR (Architecture Decision Records), C4-диаграммы
- **Код и исполняемые артефакты** — агенты, ассистенты, инструменты, Apps SDK, MCP-серверы, CI/CD-скрипты
- **Контент для продвижения** — маркетинговые материалы, публикации, выступления, манифесты
- **Операционные данные** — метрики, логи событий (Activity Hub), эпистемические статусы, доказательства
- **Управленческие артефакты** — планы работ, дорожная карта, список решений, входящие запросы

**Вопросы для решения:**
1. Какие артефакты должны храниться в текущем Git-репозитории (ecosystem-development)?
2. Что размещается в отдельных репозиториях (например, agents-core, apps-sdk)?
3. Где хранить операционные данные подсистем (базы данных, S3, специализированные хранилища)?
4. Где хранить и как организовать доступ к знаниям экосистемы, которая генерируется в клубе, чатах, в ДЗ и т.п? Эти знания очень полезны для обучения наших ИИ-моделей. 
5. Как организовать связи между артефактами в разных хранилищах (ссылки, метаданные)?
6. Какие правила доступа применять к разным типам информации (public/internal/restricted)?

---

### 2. Утверждение списка подсистем

**Контекст**
В документе [[4.1. Список подсистем]] описаны 17 подсистем экосистемы. Необходимо валидировать этот список, определить приоритеты разработки и зафиксировать границы ответственности каждой подсистемы.

**Текущий список подсистем:**
1. Список подсистем (реестр) — 4.1
2. Операционная система ИИ-платформы — 4.2
3. Клуб (systemsworld.club) — 4.3
4. Платформа обучения (LMS) — 4.4
5. Проводник по персональному маршруту — 4.5
6. Система учета активностей (Activity Hub) — 4.6
7. CRM — 4.7
8. Системы приема оплаты фиатом — 4.8
9. Биллинг — 4.9
10. Финансовая система токеномики — 4.10
11. Цифровой двойник (Digital Twin) — 4.11
12. Единое хранилище знаний (Memory Bank) — 4.12
13. Система управления кейсами — 4.13
14. Система идентификации и доступа (ORY) — 4.14
15. Apps SDK и маркетплейс ассистентов — 4.15
16. Эпистемический граф и статусы (ESG) — 4.16
17. Система Proof-of-Impact — 4.17

**Вопросы для решения:**
1. Все ли перечисленные подсистемы необходимы для MVP экосистемы?
2. Какие подсистемы являются критичными для первой версии (v1.0)?
3. Нужно ли добавить дополнительные подсистемы (например, систему уведомлений, аналитическую платформу)?
4. Правильно ли определены границы и зоны ответственности каждой подсистемы?
5. Какие подсистемы можно объединить или разделить для оптимизации архитектуры?

---

### 3. Концепция использования экосистемы

**Контекст**
Необходимо зафиксировать ключевые сценарии использования (use cases) экосистемы для разных ролей участников. Это определит приоритеты в разработке функциональности и поможет выстроить понятный путь (customer journey) для каждой персоны. Смотри раздел 1.4. Концепция функционирования экосистемы. 

**Основные роли участников:**
- **Ученик/Стажёр** — учится по персональному маршруту, получает рекомендации от ИИ-проводника
- **Создатель/Методист** — производит методички, курсы, определения с помощью ИИ-ассистентов
- **Куратор/Ментор** — курирует траектории других участников, подтверждает достижения
- **Разработчик ИИ-агентов** — публикует ассистентов и инструменты через Apps SDK
- **Организатор проектов** — инициирует и ведёт прикладные проекты сообщества
- **Новичок клуба** — входит в культуру через онбординг. 

**Вопросы для решения:**
1. Какие сквозные сценарии (end-to-end) должны работать в первой версии?
2. Как выглядит типичный путь участника от онбординга до первого значимого результата?
3. Какие точки взаимодействия между ролями являются критичными (например, ментор ↔ ученик)?
4. Как участники будут получать вознаграждение (фиат + токены) за свой вклад?
5. Какие инструменты и интерфейсы нужны для каждой роли (веб-интерфейсы, боты, API)?
6. Как обеспечить быстрый онбординг новых участников (гайды, демо, walkthrough)?

---

## Решения (будут добавляться по мере принятия)

_Здесь будут фиксироваться принятые решения в формате ADR (Architecture Decision Records)._

### Список всех ADR (автогенерация)

```dataview
LIST
FROM "content/0. Управление"
WHERE contains(file.name, "0.3. Решения")
FLATTEN file.lists as item
WHERE contains(item, "ADR-")
```

> **Примечание:** Для удобства навигации используйте содержание ниже или поиск по документу (Ctrl+F / Cmd+F).

---

### ADR-001: Детализация архитектуры Финансовой системы токеномики (4.10)

**Дата:** 2025-11-13
**Статус:** Принято
**Контекст:** Система токеномики была описана на высоком уровне, требовалась детализация компонентов, процессов и интеграций для обеспечения прозрачности экономики вклада.

**Решение:** Переписана архитектура системы 4.10 с детализацией:
- **6 компонентов:** Emission Center, Reward Calculator, Token Ledger, Internal Exchange, Treasury & Liquidity Manager, Compliance & Anti-Fraud
- **5 процессов:** начисление токенов через Proof-of-Impact, оплата услуг токенами, стабилизация экономики, перераспределение от неактивных пользователей, квартальная отчётность
- **Технологический стек:** Solana blockchain для SPL-токенов, PostgreSQL для внутреннего учёта, Python для бизнес-логики
- **API и контракты:** REST API для операций с токенами, события для интеграции с Activity Hub
- **Roadmap:** 3 фазы развития (v1.0 MVP, v1.1 расширение, v2.0 полная автоматизация)

**Последствия:**
- ✅ Прозрачная архитектура токеномики с чёткими границами компонентов
- ✅ Встроенные механизмы защиты от fraud (заморозка, окна регрессии, compliance)
- ✅ Внутренняя биржа для обмена токенов на услуги участников
- ✅ Treasury management для стабилизации экономики
- ⚠️ Требует интеграции с Solana blockchain (дополнительная сложность)
- ⚠️ Необходима разработка Compliance компонента для соответствия регуляторным требованиям

**Связанные документы:** [[4.10. Финансовая система токеномики]], [[4.17. Система Proof-of-Impact]], [[4.9. Биллинг]], [[1.4. Концепция функционирования экосистемы для ЦА]]

---

### ADR-002: Расширение Системы управления кейсами с Pomodoro и time budgeting (4.13)

**Дата:** 2025-11-13
**Статус:** Принято
**Контекст:** Система управления кейсами требовала расширения функциональности для поддержки персонального time management, автоматической фиксации времени и уведомлений участников.

**Решение:** Переписана архитектура системы 4.13 с добавлением:
- **8 компонентов:** Case Registry, Task Management, Team Coordination, Progress Tracking, Time Management (с Pomodoro), Knowledge Capture, Notifications & Reminders, Gamification & Rewards
- **Типы задач:** постоянные (recurring), временные (time-bound), разовые (one-time)
- **Pomodoro tracker:** автоматическая фиксация времени работы в Activity Hub при завершении сессии
- **Time budgeting:** планирование недельных бюджетов времени по задачам с отслеживанием прогресса
- **Notifications:** интеграция с Telegram и email для уведомлений о дедлайнах, заданиях, ревью
- **Gamification:** система наград за выполнение задач и достижений

**Последствия:**
- ✅ Автоматическая фиксация времени работы через Pomodoro (снижение ручного труда)
- ✅ Недельное планирование с time budgeting помогает участникам управлять нагрузкой
- ✅ Система уведомлений повышает вовлечённость и своевременность выполнения
- ✅ Геймификация мотивирует участников к регулярной работе
- ✅ Поддержка образовательных проектов (деканат) и личных проектов
- ⚠️ Требует интеграции с Telegram Bot API и email-сервисом
- ⚠️ Необходима разработка логики расчёта недельных бюджетов и распределения времени

**Связанные документы:** [[4.13. Система управления кейсами]], [[4.6. Система учета активностей (хаб активностей)]], [[4.5. Проводник по персональному маршруту]], [[1.4. Концепция функционирования экосистемы для ЦА]]

---

### ADR-003: Архитектура хранения артефактов экосистемы

**Дата:** 2025-11-18
**Статус:** Принято
**Контекст:** В экосистеме присутствуют различные типы информации, требующие разных подходов к хранению, версионированию и доступу. Необходимо определить единую стратегию размещения и управления всеми артефактами.

**Решение:** Принята гибридная архитектура хранения с разделением по типам данных и требованиям к работе с ними:

#### 1. Высокоуровневая информация
**Хранилище:** Отдельный репозиторий (создать позже)
**Формат:** Markdown на разных языках (RU/EN)
**Содержание:** Видение, миссия, стратегия, концепция функционирования экосистемы, принципы развития
**Обоснование:** Краткое емкое описание на разных языках требует отдельного репозитория для удобства многоязычной поддержки

#### 2. Методология и знания
**Хранилище:** Комбинированный подход с двумя вариантами развития

**Вариант A: Полный текст руководств**
- **Репозиторий:** [aisystant/docs](https://github.com/aisystant/docs)
- **Формат:** Markdown
- **Процесс:** Разработчик пишет/редактирует полный текст руководств (руками или с помощью LLM)

**Вариант B: Knowledge Graph**
- **Основное хранилище:** SurrealDB (или другая graph database)
- **Альтернативные форматы:**
  - Git репозиторий (Markdown + YAML)
  - Coda.io (требуется механизм синхронизации)
- **Интерфейс:** Специализированный UI для редактирования графа понятий, связей, источников, заметок
- **Импорт/экспорт:** Поддержка различных форматов представления графа

**Комбинированный подход (рекомендуется):**
- Из полного текста формируется граф понятий
- Из графа понятий генерируется:
  - "Универсальное" руководство (стандартное)
  - "Индивидуальное" руководство (путешествие по графу в удобном порядке и темпе стажера)
  - "Дневник прохождения" (фактически, индивидуальное руководство с прогрессом)

**Данные из клуба и чатов:**
- **Хранилище:** SurrealDB
- **Формат:** Активные действия, заметки, ссылки, источники, комментарии
- **Интеграция:** Цифровая тень стажеров (связь с операционными данными)

#### 3. Архитектурная документация
**Хранилище:** Git + Markdown
**Высокий уровень:** [ecosystem-development](https://github.com/aisystant/ecosystem-development) — общая архитектура, ADR, C4-диаграммы
**Детали реализации:** Отдельные репозитории подсистем (например, [platform](https://github.com/aisystant/platform))
**Обоснование:** Версионный контроль, code review, история изменений, близость к коду

#### 4. Код и исполняемые артефакты
**Хранилище:** Отдельный репозиторий для каждой подсистемы на GitHub
**Структура каждого репозитория:**
- Код подсистемы
- README с кратким описанием надсистемы
- Подробное описание сервиса как "прозрачного ящика"
- CI/CD конфигурация
**Примеры:** agents-core, apps-sdk, MCP-серверы
**Обоснование:** Изоляция, независимое версионирование, CI/CD per service

#### 5. Контент для продвижения
**Хранилище:** Google Drive (временное решение)
**Содержание:** Маркетинговые материалы, публикации, выступления, манифесты
**Статус:** Требуется дальнейшая проработка
**Обоснование:** Удобство совместной работы с нетехническими специалистами

#### 6. Операционные данные
**Основное хранилище:** SurrealDB
**Содержание:**
- Метрики
- Логи событий (Activity Hub)
- Эпистемические статусы
- Доказательства (evidence)
- Цифровой след стажеров
- Активные действия, заметки, ссылки из клуба и чатов
**Обоснование:** SurrealDB становится ключевой системой платформы для хранения всех операционных данных и цифровых теней

#### 7. Управленческие артефакты
**Хранилище:** Plane (project management platform)
**Содержание:**
- Планы работ
- Дорожная карта
- Список решений
- Входящие запросы
**Обоснование:** Специализированный инструмент для управления проектами

#### Принципы микросервисной архитектуры
**Автономия сервисов:** Каждый микросервис самостоятельно принимает решения о хранении своих данных
**Платформенные сервисы:**
- **SurrealDB** — цифровой след стажера, операционные данные
- **ORY** — аутентификация и авторизация

#### Правила доступа и связи
**Модель данных и доступа:** Требует отдельной проработки совместно с @TserenTserenov
**Связи между артефактами:**
- Использование ссылок между репозиториями
- Метаданные в frontmatter документов
- API для интеграции между системами

**Последствия:**
- ✅ Четкое разделение ответственности по хранилищам
- ✅ SurrealDB как центральное хранилище операционных данных и цифровых теней
- ✅ Гибкость в выборе между текстовыми руководствами и knowledge graph
- ✅ Версионный контроль архитектурной документации и кода
- ✅ Автономия микросервисов в выборе хранилищ
- ✅ Возможность комбинированного подхода (текст → граф → персонализированные руководства)
- ⚠️ Требуется разработка модели данных и доступа для SurrealDB
- ⚠️ Необходимость синхронизации между разными хранилищами (например, Coda.io ↔ SurrealDB)
- ⚠️ Временное решение для контента продвижения требует пересмотра
- ⚠️ Сложность поддержки нескольких форматов хранения знаний (markdown vs graph)

**Дополнительные решения:**
- **Использование Dataview:** Везде где возможно использовать Dataview queries для автоматической генерации списков вместо ручного ведения (применимо к Obsidian документации)
- **Интеграция с Telegram/Chats:** Данные из клуба и телеграм-чатов автоматически сохраняются в SurrealDB для последующего использования в обучении AI-моделей

**Связанные документы:**
- [[0.6. Структура этого хранилища]]
- [[4.1. Список подсистем]]
- [[4.2. Операционная система ИИ-платформы]]
- [[4.14. Система идентификации и доступа (ORY)]]
- [[3.4. Описание единого хранилища знаний (Memory Bank)]]

---

### ADR-004: Применение Dataview для автоматической генерации списков в документации

**Дата:** 2025-11-18
**Статус:** Принято
**Контекст:** В документации экосистемы присутствует множество списков (подсистемы, ADR, документы в разделах), которые требуют ручного обновления при добавлении новых элементов. Это создает риск рассинхронизации и увеличивает трудозатраты на поддержку документации.

**Решение:** Использовать Obsidian Dataview plugin для автоматической генерации динамических списков везде, где возможно.

#### Области применения Dataview

**1. Списки подсистем**
- Документ [[4.0. Информация]] — автоматический список всех подсистем с метаданными
- Источник данных: frontmatter каждого файла подсистемы

**2. Списки ADR**
- Документ [[0.3. Решения]] — автоматический список всех Architecture Decision Records
- Источник данных: заголовки разделов в текущем документе

**3. Списки документов в информационных файлах**
- Документы `X.0. Информация.md` в каждой папке — автоматические списки всех документов раздела
- Источник данных: файлы в соответствующей папке с фильтрацией по frontmatter

**4. Таблицы классификации**
- Документ [[0.6. Структура этого хранилища]] — уже использует Python-скрипт для генерации таблицы
- Dataview может дополнять или заменять скриптовый подход для простых случаев

#### Примеры Dataview queries

**Пример 1: Список подсистем с метаданными**
```dataview
TABLE WITHOUT ID
  file.link as "Подсистема",
  layer as "Слой",
  status as "Статус",
  version as "Версия"
FROM "content/4. Системы"
WHERE file.name != "4.0. Информация"
SORT file.name ASC
```

**Пример 2: Список документов раздела**
```dataview
TABLE WITHOUT ID
  file.link as "Документ",
  type as "Тип",
  status as "Статус",
  created as "Создан"
FROM "content/1. Идеи развития экосистемы"
WHERE file.name != "1.0 Информация"
SORT file.name ASC
```

**Пример 3: Список активных задач (если используются TODO в markdown)**
```dataview
TASK
WHERE !completed
FROM "content/0. Управление"
GROUP BY file.link
```

**Пример 4: Timeline принятых решений**
```dataview
TABLE
  split(file.name, ":")[0] as "ADR",
  split(file.name, ":")[1] as "Название"
FROM "content/0. Управление/0.3. Решения"
WHERE contains(file.outlinks, "ADR-")
SORT file.name ASC
```

#### Требования к frontmatter для Dataview

Для корректной работы Dataview queries каждый документ должен содержать frontmatter с обязательными полями:

```yaml
---
type: doc|data|code|policy|metric
status: draft|in_progress|active|approved|archived
created: YYYY-MM-DD
version: X.Y
layer: philosophy|methodology|architecture|service|...
---
```

Дополнительные поля могут добавляться в зависимости от типа документа.

#### Преимущества и ограничения

**Последствия:**
- ✅ Автоматическое обновление списков при добавлении новых документов
- ✅ Снижение трудозатрат на поддержку документации
- ✅ Гарантия актуальности списков (нет риска "забыть добавить")
- ✅ Единообразие представления данных
- ✅ Возможность фильтрации и сортировки по различным критериям
- ✅ Интеграция с существующей системой метаданных (frontmatter)
- ⚠️ Требуется Obsidian с установленным Dataview plugin для корректного отображения
- ⚠️ При экспорте в другие форматы (PDF, HTML) Dataview queries могут не работать
- ⚠️ Необходимо поддерживать консистентность frontmatter во всех документах
- ⚠️ Сложные queries могут быть менее читаемы для новичков

#### Рекомендации по использованию

1. **Использовать Dataview для:**
   - Списков документов в информационных файлах (X.0. Информация)
   - Списков элементов с метаданными (подсистемы, ADR)
   - Агрегации данных по разделам
   - Фильтрации по статусам, типам, датам

2. **Не использовать Dataview для:**
   - Детальных описаний (лучше использовать обычный markdown)
   - Сложных таблиц с ручным форматированием
   - Контента, который экспортируется в форматы без поддержки Dataview

3. **Fallback стратегия:**
   - При необходимости экспорта использовать Python-скрипты для генерации статических списков
   - Поддерживать как Dataview queries, так и статические списки в критичных документах

**Связанные документы:**
- [[0.6. Структура этого хранилища]] — общие правила организации документации
- [[0.7. Классификация документов и теги]] — система метаданных
- [[4.0. Информация]] — пример применения Dataview для списка подсистем

**Инструменты:**
- [Dataview Plugin Documentation](https://blacksmithgu.github.io/obsidian-dataview/)
- Python скрипты в `ops/` для генерации статических списков

---